<chapter id="development">
	<title>General</title>

	<para>As has been said in the introduction, ctrlproxy 
	is easily extendible. At the time of writing, there 
	are nine modules available. </para>

	<para>The simplest possible module would be:</para>

	<programlisting>
	<![CDATA[
#include <ctrlproxy.h>

gboolean init_plugin(struct plugin *p)
{   
	/* Do something */
	return TRUE;
}

gboolean fini_plugin(struct plugin *p)
{
	/* Free my structures here */
	return TRUE;
}

	]]>
	</programlisting>

	<para>The init_plugin function is called when the module is loaded. 
	In this function, you should register whatever functions the module 
	provides, such as a 'message handler' or a transport. You 
	can use the <parameter>data</parameter> member of the 
	plugin struct to store data for your plugin. This function 
	should return a boolean: false when initialisation failed 
	or true when it succeeded.</para>

<para>THe fini_plugin function is called before the module is unloaded.
	In this function, you should free the data structures your module is 
	using and make sure there are no other pointers in ctrlproxy pointing 
	to functions or data structures from your module. For example, 
	unregister transports or hooks.</para>

<para>The fini_plugin should return a boolean as well. This value should be 
	true if the unloading may preceed, or false if there are reasons 
	ctrlproxy should not attempt to unload the module (such as resources 
	that are currently in use, etc).</para>

	<sect1><title>Building and installing</title>

	<para>A module is in fact a shared library that's loaded 
	at run-time, when the program is already running. The <filename>.so</filename> file can compiled with a command like:</para>

	<screen>
<prompt>$ </prompt><userinput>gcc -shared -o foo.so input1.c input2.o input3.c</userinput>
	</screen>

	</sect1>

	<sect1><title>Message handler functions</title>

	<para>A message handling function is a function that is called 
	whenever ctrlproxy receives an IRC message. The only argument 
	this function should have would be a line struct. </para>

	<para>Flags can be set on the line (the field in the struct 
	to use is called 'options') to influence the handling 
	of the packet by the rest of ctrlproxy. At the time of writing, 
	the following two flags are available:</para>

	<variablelist>
		<varlistentry><term>LINE_DONT_SEND</term>
		<listitem><para>Continue processing, but do not send this line.</para></listitem>
		</varlistentry>

		<varlistentry><term>LINE_STOP_PROCESSING</term>
			<listitem><para>Immediately stop processing the line (passing it to other message handlers). Implemented as of version 2.5.</para></listitem>
		</varlistentry>

		<varlistentry><term>LINE_NO_LOGGING</term>
			<listitem><para>Modules that do logging should ignore this line. This may be used for PRIVMSG's that are not interesting for logs, such as timestamps that are being printed. </para></listitem>
		</varlistentry>
	</variablelist>

	<para>There is one other option that can be specified, but is only 
	useful when sending your own messages:</para>

	<variablelist>
		<varlistentry><term>LINE_IS_PRIVATE</term>
		<listitem><para>Do not send this line to other 
		clients currently connected.</para></listitem>
		</varlistentry>
	</variablelist>

	<sect2><title>Registering a message handler</title>

	<para>All IRC lines that ctrlproxy receives and sends are passed thru 
		so-called 'filter functions'. These functions can do things based on 
		the contents of these lines, change the lines or stop further 
		processing of these lines. </para>

	<para>To add a filter function, call 'add_filter'. To remove the filter 
		function again (usually when your plugin is being unloaded) call 'del_filter'.</para>

	<para>Example:</para>

	<programlisting>
...
add_filter("my_module", my_message_handler);
...
	</programlisting>

	<para>The prototype for the message handling function in the example 
	above would look something like this:
	</para>

	<programlisting>
static gboolean my_message_handler(struct line *l);
	</programlisting>

	<para>Your message handler should return TRUE if the rest of the filter 
		functions should also see the message and FALSE if ctrlproxy should 
		stop running filter functions on the given line struct.</para>

	<note><para>These hooks are executed <emphasis>before</emphasis> 
		the data as returned by find_channel() and find_nick() is updated</para>
</note>

	</sect2>

	<sect2><title>Registering a new client/server or lose client/server handler</title>

	<para>A module can also register a function that should be called when a new 
		client connects or when a client disconnects and when the server has successfully connected to 
		the client or when the connection to the client is broken.</para>

	<programlisting>
typedef gboolean (*new_client_hook) (struct client *);
typedef void (*lose_client_hook) (struct client *);
void add_new_client_hook(char *name, new_client_hook h);
void del_new_client_hook(char *name);
void add_lose_client_hook(char *name, lose_client_hook h);
void del_lose_client_hook(char *name);

typedef void (*server_connected_hook) (struct network *);
typedef void (*server_disconnected_hook) (struct network *);
void add_server_connected_hook(char *name, server_connected_hook);
void del_server_connected_hook(char *name);
void add_server_disconnected_hook(char *name, server_disconnected_hook);
void del_server_disconnected_hook(char *name);
	</programlisting>

	<para>The prototypes of these functions pretty much speak for themselves. 
	If a new_client_hook function returns FALSE, the client will be denied 
	access.</para>

	</sect2>

	<sect2>
		<title>Registering a MOTD function</title>

		<para>MOTD functions are functions that add one or more lines to 
			the MOTD that is sent to a client.</para>

		<para>A module can register a MOTD function using the add_motd_hook() and del_motd_hook() functions, that work similar to the add_new_client_hook() and del_new_client_hook() functions documented above.</para>

		<para>A motd function should return a dynamically allocated array containing dynamically allocated nul-terminated strings that should be added to the MOTD.</para>

	</sect2>

	</sect1>

	<sect1><title>Log functionality</title>

	<para>Ctrlproxy uses GLib's logging functions. Read the related section in the GLib documentation for details.</para>

	</sect1>

	<sect1><title>Storing data</title>

	<para>Paths to data should be configurable, but default to 
	the file/directory name returned by <parameter>ctrlproxy_path()</parameter>. The argument to this function should be the name of the subsystem.</para>
	
	<para>All top level directories have been created when this function 
	returns. </para>

	<para>If NULL was returned, one or more directories could not be created.</para>

	</sect1>

	<sect1><title>Debugging</title>

		<para>Two very useful utilities are <command>valgrind</command> 
			and <command>gdb</command>. </para>

		<para>If you're running from gdb, make sure you have set the following: </para>

		<para><programlisting>
		handle SIGPIPE nostop
		handle SIGINT nostop
		</programlisting></para>
		</sect1>

</chapter>
